<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Word Grid â€” styled</title>
<style>
  html,body { height:100%; margin:0; }
  body {
    font-family: sans-serif;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding: 36px;
    box-sizing: border-box;
    background: #fafafa;
  }
  .game {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  .theme { background: lightblue; padding: 8px 12px; border-radius:6px; }
  .found-count { margin: 4px 0; }
  .current-word { font-size: 24px; text-align: center; min-height:28px; }

  .grid {
    position: relative;
    display: inline-block;
    padding: 8px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.06);
  }

  .row { display: flex; }
  .letter {
    width: 40px; height: 40px; margin: 5px;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer; color: black;
    position: relative; user-select: none; z-index: 1;
  }

  .letter.selected::after,
  .letter.found-blue::after,
  .letter.found-yellow::after {
    content: "";
    position: absolute;
    width: 40px; height: 40px;
    border-radius: 50%;
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    z-index: -1;
  }
  .letter.selected::after { background: #DBD8C7; }
  .letter.found-blue::after { background: #B8DEEC; }
  .letter.found-yellow::after { background: #F1D046; }

  .hint-highlight { border: 2px dashed lightblue; box-sizing: border-box; }

  .hint-button {
    background: white; color: black; border: 1px solid #333;
    border-radius: 20px; padding: 10px 20px; cursor: pointer; font-size: 16px;
  }
  .inverted { background: black; color: white; }

  svg.edges {
    position: absolute;
    top: 0; left: 0;
    pointer-events: none;
    z-index: 0;
    overflow: visible;
  }
</style>
</head>
<body>
<div class="game">
  <div class="theme">TODAY'S THEME <br> Simply divine</div>
  <div class="found-count">0 of 6 theme words found.</div>
  <div class="current-word"></div>

  <div class="grid">
    <svg class="edges"></svg>
  </div>

  <button class="hint-button">Hint</button>
</div>

<script>
const gridLetters = [
  "AVENSE".split(''),
  "EDLARN".split(''),
  "HAMEHT".split(''),
  "HREENR".split(''),
  "ACSSGE".split(''),
  "NGDAGH".split(''),
  "ENIRUP".split(''),
  "LASERA".split('')
];
const themeWords = ['ARCHANGEL', 'HERALD', 'MESSENGER', 'GUARDIAN', 'SERAPH'];
const spangram = 'HEAVENSENT';
const allSolutions = [...themeWords, spangram];
const wordToPath = {
  'ARCHANGEL': [[2,1],[3,1],[4,1],[3,0],[4,0],[5,0],[5,1],[6,0],[7,0]],
  'HERALD': [[2,4],[2,3],[1,4],[1,3],[1,2],[1,1]],
  'MESSENGER': [[2,2],[3,2],[4,2],[4,3],[3,3],[3,4],[4,4],[4,5],[3,5]],
  'GUARDIAN': [[5,4],[6,4],[5,3],[6,3],[5,2],[6,2],[7,1],[6,1]],
  'SERAPH': [[7,2],[7,3],[7,4],[7,5],[6,5],[5,5]],
  'HEAVENSENT': [[2,0],[1,0],[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[1,5],[2,5]]
};

let found = new Set();
let currentPath = [];
let permanentEdges = [];
let mistakeCount = 0;
let spentHints = 0;
let words = new Set();
let submittedNonSolutions = new Set();

async function loadDictionary() {
  try {
    const res = await fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt');
    const text = await res.text();
    words = new Set(text.split('\n').map(w => w.trim().toLowerCase()).filter(w => w.length >= 4));
  } catch (e) {
    console.error('Failed to load dictionary. Using fallback.');
    words = new Set(['amen', 'real', 'word', 'test', 'laser', 'angel']);
  }
  allSolutions.forEach(w => words.add(w.toLowerCase()));
}
loadDictionary();

const grid = document.querySelector('.grid');
const edgesSvg = document.querySelector('svg.edges');
const currentWordDiv = document.querySelector('.current-word');
const foundCountDiv = document.querySelector('.found-count');
const hintButton = document.querySelector('.hint-button');
hintButton.addEventListener('click', handleHint);

function updateHintButton() {
  const earned = Math.floor(mistakeCount / 3);
  const hintsAvailable = earned - spentHints;
  const currentProgress = mistakeCount % 3;
  let filledFraction = currentProgress / 3;
  if (hintsAvailable > 0) {
    filledFraction = 1;
    hintButton.classList.add('inverted');
  } else {
    hintButton.classList.remove('inverted');
  }
  hintButton.style.background = `linear-gradient(to right, lightgray ${filledFraction * 100}%, white ${filledFraction * 100}%)`;
}

function clearHints() {
  document.querySelectorAll('.hint-highlight').forEach(el => el.classList.remove('hint-highlight'));
}

function handleHint() {
  const hintsAvailable = Math.floor(mistakeCount / 3) - spentHints;
  if (hintsAvailable <= 0) return;
  spentHints += 1;
  updateHintButton();
  clearHints();
  const unsolved = allSolutions.filter(w => !found.has(w));
  if (unsolved.length === 0) return;
  const randWord = unsolved[Math.floor(Math.random() * unsolved.length)];
  const path = wordToPath[randWord];
  path.forEach(([r, c]) => getCell(r, c).classList.add('hint-highlight'));
}

function isAdjacent(p1, p2) {
  const dr = Math.abs(p1[0] - p2[0]);
  const dc = Math.abs(p1[1] - p2[1]);
  return dr <= 1 && dc <= 1 && !(dr === 0 && dc === 0);
}

function clearPath() {
  document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
  currentPath = [];
  currentWordDiv.textContent = '';
  drawEdges();
}

function submit() {
  if (currentPath.length < 4) {
    clearPath();
    return;
  }
  const word = currentPath.map(([r, c]) => gridLetters[r][c]).join('').toUpperCase();
  const lower = word.toLowerCase();
  if (!words.has(lower)) {
    clearPath();
    return;
  }
  if (allSolutions.includes(word)) {
    const isSpangram = word === spangram;
    const className = isSpangram ? 'found-yellow' : 'found-blue';
    const edgeColor = isSpangram ? '#F1D046' : '#B8DEEC';
    currentPath.forEach(([r, c]) => {
      const cell = getCell(r, c);
      cell.classList.remove('found-blue', 'found-yellow', 'selected');
      cell.classList.add(className);
    });
    found.add(word);
    foundCountDiv.textContent = `${found.size} of 6 theme words found.`;

    // Store edges permanently
    for (let i = 1; i < currentPath.length; i++) {
      const [r1, c1] = currentPath[i - 1];
      const [r2, c2] = currentPath[i];
      permanentEdges.push([r1, c1, r2, c2, edgeColor]);
    }
    drawEdges();
  } else {
    if (submittedNonSolutions.has(lower)) {
      currentWordDiv.textContent = 'Word already found...';
      setTimeout(() => {
        clearPath();
      }, 2000);
    } else {
      submittedNonSolutions.add(lower);
      mistakeCount += 1;
      updateHintButton();
      clearPath();
    }
  }
}

function handleClick(r, c) {
  clearHints();
  const pos = [r, c];
  if (currentPath.length === 0) {
    currentPath = [pos];
    getCell(r, c).classList.add('selected');
  } else {
    const last = currentPath[currentPath.length - 1];
    if (last[0] === r && last[1] === c) {
      submit();
      return;
    }
    if (isAdjacent(last, pos) && !currentPath.some(p => p[0] === r && p[1] === c)) {
      currentPath.push(pos);
      getCell(r, c).classList.add('selected');
    } else {
      clearPath();
      currentPath = [pos];
      getCell(r, c).classList.add('selected');
    }
  }
  drawEdges();
  const word = currentPath.map(([rr, cc]) => gridLetters[rr][cc]).join('').toUpperCase();
  currentWordDiv.textContent = word;
}

function getCell(r, c) {
  return grid.children[r + 1].children[c];
}

function drawEdges() {
  edgesSvg.innerHTML = "";

  // Draw permanent edges
  for (const [r1, c1, r2, c2, color] of permanentEdges) {
    drawLine(r1, c1, r2, c2, color);
  }

  // Draw current selection edges
  for (let i = 1; i < currentPath.length; i++) {
    const [r1, c1] = currentPath[i - 1];
    const [r2, c2] = currentPath[i];
    const cell1 = getCell(r1, c1);
    let color = "#DBD8C7";
    if (cell1.classList.contains('found-yellow')) color = "#F1D046";
    else if (cell1.classList.contains('found-blue')) color = "#B8DEEC";
    drawLine(r1, c1, r2, c2, color);
  }
}

function drawLine(r1, c1, r2, c2, color) {
  const cell1 = getCell(r1, c1);
  const cell2 = getCell(r2, c2);
  const rect1 = cell1.getBoundingClientRect();
  const rect2 = cell2.getBoundingClientRect();
  const gridRect = grid.getBoundingClientRect();
  const x1 = rect1.left - gridRect.left + rect1.width / 2;
  const y1 = rect1.top - gridRect.top + rect1.height / 2;
  const x2 = rect2.left - gridRect.left + rect2.width / 2;
  const y2 = rect2.top - gridRect.top + rect2.height / 2;

  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", x1);
  line.setAttribute("y1", y1);
  line.setAttribute("x2", x2);
  line.setAttribute("y2", y2);
  line.setAttribute("stroke", color);
  line.setAttribute("stroke-width", "12");
  line.setAttribute("stroke-linecap", "round");
  edgesSvg.appendChild(line);
}

/* build grid */
gridLetters.forEach((rowLetters, r) => {
  const row = document.createElement('div');
  row.classList.add('row');
  rowLetters.forEach((letter, c) => {
    const letDiv = document.createElement('div');
    letDiv.classList.add('letter');
    letDiv.textContent = letter;
    letDiv.addEventListener('click', () => handleClick(r, c));
    row.appendChild(letDiv);
  });
  grid.appendChild(row);
});

window.addEventListener('resize', () => {
  edgesSvg.setAttribute("width", grid.offsetWidth);
  edgesSvg.setAttribute("height", grid.offsetHeight);
  if (currentPath.length > 1 || permanentEdges.length > 0) drawEdges();
});

updateHintButton();
</script>
</body>
</html>
<!-- version simple --> 