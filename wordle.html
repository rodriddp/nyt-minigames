<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=0.9" />
<title>Mini Wordle - HTML/JS</title>
<style>
  :root{
    --bg: #ffffff;
    --tile-border: #d1d5db;
    --tile-bg: #ffffff;
    --tile-text: #000000;
    --green: #6aaa64;
    --yellow: #c9b458;
    --gray: #787c7e;
    --keyboard-gray: #d3d6da;
    --kbd-dark: #6b7280;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:#111827;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:40px 20px 20px 20px;
  }
  .topbar { width: 100%; background: #ffffff; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; padding: 8px 12px; position: fixed; top: 0; left: 0; z-index: 1000; }
  .topbar-icon { height: 40px; width: 145px; cursor: pointer; }

  .container{ width:min(320px, 92vw); display:flex; flex-direction:column; gap:25px; align-items:center; }

  .board{ display: grid; grid-template-rows: repeat(6, 1fr); gap:5px; width:100%; }
  .row{ display:grid; grid-template-columns: repeat(5, 1fr); gap:5px; }
  .tile { aspect-ratio: 1/1; border-radius: 0; border: 2px solid var(--tile-border); background: var(--tile-bg); display: flex; justify-content: center; align-items: center; font-weight: 700; font-size: clamp(24px, 4.5vw, 28px); color: var(--tile-text); text-transform: uppercase; user-select: none; transform-style: preserve-3d; }
  .tile.filled { border-color: #888A8C; }
  .tile.green{ background: var(--green); color: #ffffff; border-color: var(--green); }
  .tile.yellow{ background: var(--yellow); color: #ffffff; border-color: var(--yellow); }
  .tile.gray{ background: var(--gray); color: #ffffff; border-color: var(--gray); }

  .keyboard{ width:100%; display:flex; flex-direction:column; gap:2px; user-select:none; }
  .krow{ display:flex; gap:2px; justify-content:center; }
  .key{ padding: 15px 10px; min-width: 40px; min-height: 55px; border-radius: 6px; background: var(--keyboard-gray); color: #111827; font-weight:600; text-transform:uppercase; display:flex; justify-content:center; align-items:center; cursor:pointer; border: none; box-shadow: none; font-size: 17px; }
  .key.big{ min-width: 64px; padding-left:14px; padding-right:14px; min-height: 50px; font-size: 12px; }
  .key[data-key="enter"] { font-size: 12px; }
  .key[data-key="back"] { font-size: 16px; }
  .key.green{ background: var(--green); color: #fff; }
  .key.yellow{ background: var(--yellow); color: #fff; }
  .key.dark{ background: var(--kbd-dark); color: #fff; }

  .status{ min-height:22px; font-size:14px; color:#374151; text-align:center; }

  @media (max-width:420px){ .key{ padding: 12px 8px; min-width: 34px; min-height: 40px; font-size: 13px; } .key.big{ min-width: 60px; min-height: 40px; } }

  .tile.flip { animation: flip 600ms ease forwards; }
  @keyframes flip { 0% { transform: rotateX(0deg);} 50% { transform: rotateX(90deg);} 100% { transform: rotateX(0deg);} }
</style>
</head>
<body>
  <div class="topbar">
    <a href="index.html">
      <img src="icons/nyt_logo.png" alt="Back" class="topbar-icon">
    </a>
    <button id="newGameBtn" style="
      padding: 10px 20px; 
      border: 1px solid #333; 
      border-radius: 25px; 
      background: white; 
      cursor: pointer; 
      font-weight: bold; 
      color: black;
      transition: filter 0.2s;
      margin-left: auto;
      -webkit-tap-highlight-color: transparent;margin-right: 60px;
    ">New Game</button>
  </div>

  <div class="container">
    <div class="status" id="status"></div>
    <div class="board" id="board" aria-label="Wordle board"></div>
    <div class="keyboard" id="keyboard" aria-label="Keyboard"></div>
    <small style="color:#6b7280; margin-top:6px">Type with your keyboard or click the keys. Press Enter to submit.</small>
  </div>

<script>
(function(){
  const SOLUTION = "party";
  const MAX_ROWS = 6;
  const WORD_LENGTH = 5;

  let board = Array.from({length: MAX_ROWS},()=>Array(WORD_LENGTH).fill(''));
  let currentRow = 0;
  let currentCol = 0;
  let gameOver = false;
  let VALID_WORDS = new Set();

  const boardEl = document.getElementById('board');
  const keyboardEl = document.getElementById('keyboard');
  const statusEl = document.getElementById('status');

  async function loadValidWords() {
    try {
      const resp = await fetch('https://gist.githubusercontent.com/dracos/dd0668f281e685bad51479e5acaadb93/raw/valid-wordle-words.txt');
      const text = await resp.text();
      VALID_WORDS = new Set(text.split('\n').map(w=>w.trim().toLowerCase()).filter(w=>w.length===WORD_LENGTH));
    } catch(e){ console.error(e); setStatus('Failed to load word list'); }
  }

  function createBoard(){
    boardEl.innerHTML = '';
    for (let r=0;r<MAX_ROWS;r++){
      const rowEl=document.createElement('div'); rowEl.className='row'; rowEl.dataset.row=r;
      for (let c=0;c<WORD_LENGTH;c++){
        const tile=document.createElement('div'); tile.className='tile'; tile.dataset.row=r; tile.dataset.col=c; rowEl.appendChild(tile);
      }
      boardEl.appendChild(rowEl);
    }
  }

  const rowsArr=[['q','w','e','r','t','y','u','i','o','p'],['a','s','d','f','g','h','j','k','l'],['enter','z','x','c','v','b','n','m','back']];
  function createKeyboard(){
    keyboardEl.innerHTML='';
    rowsArr.forEach(r=>{
      const rEl=document.createElement('div'); rEl.className='krow';
      r.forEach(k=>{
        const keyEl=document.createElement('button'); keyEl.className='key'; if(k==='enter'||k==='back') keyEl.classList.add('big');
        keyEl.dataset.key=k; keyEl.textContent = k==='back'?'⌫':k==='enter'?'Enter':k;
        keyEl.addEventListener('click',()=>onKey(k)); rEl.appendChild(keyEl);
      });
      keyboardEl.appendChild(rEl);
    });
  }

  function refreshBoard() {
    for (let r=0;r<MAX_ROWS;r++){
      for (let c=0;c<WORD_LENGTH;c++){
        const tile = boardEl.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`);
        const ch = board[r][c]||''; tile.textContent = ch.toUpperCase();
        if(ch) tile.classList.add('filled'); else tile.classList.remove('filled');
        if(r>=currentRow) tile.classList.remove('green','yellow','gray');
      }
    }
  }

  function onKey(key){ if(gameOver) return; if(key==='enter'){submitGuess();return;} if(key==='back'){handleBackspace();return;} if(/^[a-z]$/.test(key)){handleLetter(key);} }

  function handleLetter(letter){ if(currentCol>=WORD_LENGTH) return; board[currentRow][currentCol]=letter; currentCol++; refreshBoard(); saveGameStateWordle(); }
  function handleBackspace(){ if(currentCol<=0) return; currentCol--; board[currentRow][currentCol]=''; refreshBoard(); saveGameStateWordle(); }

  function submitGuess(){
    if(currentCol!==WORD_LENGTH){ setStatus("Not enough letters"); return; }
    const guess = board[currentRow].join('').toLowerCase();
    if(VALID_WORDS.size>0 && !VALID_WORDS.has(guess)){ setStatus("Not a valid word"); return; }
    evaluateGuess(guess);
  }

  function evaluateGuess(guess){
    const solution=SOLUTION.toLowerCase();
    const letters=solution.split(''); const result=Array(WORD_LENGTH).fill(null);
    const count={}; letters.forEach(ch=>count[ch]=(count[ch]||0)+1);
    for(let i=0;i<WORD_LENGTH;i++){ if(guess[i]===solution[i]){result[i]='green'; count[guess[i]]--; } }
    for(let i=0;i<WORD_LENGTH;i++){ if(result[i]) continue; const ch=guess[i]; if(count[ch]&&count[ch]>0){result[i]='yellow'; count[ch]--;}else{result[i]='gray';} }

    for(let i=0;i<WORD_LENGTH;i++){
      const tile=boardEl.querySelector(`.tile[data-row="${currentRow}"][data-col="${i}"]`);
      tile.classList.remove('green','yellow','gray'); 
      setTimeout(()=>{
        tile.classList.add('flip'); 
        setTimeout(()=>{
          tile.classList.add(result[i]); 
          },300);
        setTimeout(()=>{
          tile.classList.remove('flip'); 
          },600);
      }, i*400);
    }

    const lastTileDelay=(WORD_LENGTH-1)*400+600;
    setTimeout(()=>{
      for(let i=0;i<WORD_LENGTH;i++) updateKeyColor(guess[i], result[i]);
      saveGameStateWordle(); // Save after coloring
    }, lastTileDelay);

    if(guess===solution){
      setTimeout(()=>{ setStatus("Fabulous!",true,true);  
      gameOver=true;

    }, lastTileDelay);
    } else {
      currentRow++; currentCol=0;
      if(currentRow>=MAX_ROWS){ setTimeout(()=>{ setStatus(`Game over — solution was "${solution.toUpperCase()}"`); gameOver=true; saveGameStateWordle(); }, lastTileDelay); }
      else { setTimeout(()=>{ setStatus(''); }, lastTileDelay); }
    }
  }

  function updateKeyColor(letter,color){
    letter=letter.toLowerCase(); const keyEl=keyboardEl.querySelector(`button[data-key="${letter}"]`); if(!keyEl) return;
    keyEl.classList.remove('green','yellow','dark');
    if(color==='green') keyEl.classList.add('green'); else if(color==='yellow') keyEl.classList.add('yellow'); else if(color==='gray') keyEl.classList.add('dark');
  }

  function setStatus(text, blackBox=false, persist=false){
    statusEl.textContent = text;
  
    if (blackBox){
      statusEl.style.background = "#000";
      statusEl.style.color = "#fff";
      statusEl.style.padding = "6px 12px";
      statusEl.style.borderRadius = "6px";
    } else {
      statusEl.style.background = "transparent";
      statusEl.style.color = "#374151";
      statusEl.style.padding = "0";
    }
  
    clearTimeout(statusEl._timer);
  
    if (!persist && text) {
      statusEl._timer = setTimeout(() => {
        if (statusEl.textContent === text) statusEl.textContent = '';
      }, 1600);
    }
  }
  
  

  window.addEventListener('keydown',(e)=>{ if(gameOver) return; if(e.key==='Enter'){onKey('enter'); e.preventDefault(); } else if(e.key==='Backspace'){onKey('back'); e.preventDefault(); } else{ const k=e.key.toLowerCase(); if(/^[a-z]$/.test(k)) onKey(k); } });

  // --- SAVE / LOAD ---
  function saveGameStateWordle() {
    const state = {
      board,
      tileColors: Array.from(boardEl.querySelectorAll('.tile')).map(tile=>{
        if(tile.classList.contains('green')) return 'green';
        if(tile.classList.contains('yellow')) return 'yellow';
        if(tile.classList.contains('gray')) return 'gray';
        return '';
      }),
      currentRow,
      currentCol,
      gameOver,
      keyboardColors: Array.from(keyboardEl.querySelectorAll('.key')).map(k=>{
        const key=k.dataset.key; let color=''; if(k.classList.contains('green')) color='green'; else if(k.classList.contains('yellow')) color='yellow'; else if(k.classList.contains('dark')) color='gray'; return {key,color};
      })
    };
    localStorage.setItem('miniWordleState',JSON.stringify(state));
  }

  function loadGameStateWordle(){
    const saved=localStorage.getItem('miniWordleState');
    if(!saved) return false;
    try{
      const state=JSON.parse(saved); if(!state.board) return false;
      board=state.board; currentRow=state.currentRow??0; currentCol=state.currentCol??0; gameOver=state.gameOver??false;

      const tiles=boardEl.querySelectorAll('.tile');
      tiles.forEach((tile,idx)=>{
        const r=Number(tile.dataset.row), c=Number(tile.dataset.col);
        tile.textContent=board[r][c]?board[r][c].toUpperCase():'';
        tile.classList.remove('green','yellow','gray','filled'); if(board[r][c]) tile.classList.add('filled');
        if(state.tileColors && state.tileColors[idx]){ const color=state.tileColors[idx]; if(color) tile.classList.add(color);}
      });

      if(state.keyboardColors){
        state.keyboardColors.forEach(kc=>{
          const keyEl=keyboardEl.querySelector(`button[data-key="${kc.key}"]`); if(!keyEl) return;
          keyEl.classList.remove('green','yellow','dark');
          if(kc.color==='green') keyEl.classList.add('green');
          else if(kc.color==='yellow') keyEl.classList.add('yellow');
          else if(kc.color==='gray') keyEl.classList.add('dark');
        });
      }
      return true;
    } catch(e){ console.error(e); return false; }
  }

  // --- INIT ---
  loadValidWords();
  createBoard();
  createKeyboard();
  loadGameStateWordle(); // load previous state
  refreshBoard();

  // --- New Game button ---
document.getElementById('newGameBtn').addEventListener('click', () => {
  // Clear localStorage
  localStorage.removeItem('miniWordleState');

  // Reset state
  board = Array.from({length: MAX_ROWS},()=>Array(WORD_LENGTH).fill(''));
  currentRow = 0;
  currentCol = 0;
  gameOver = false;

  // Clear tiles
  boardEl.querySelectorAll('.tile').forEach(tile => {
    tile.textContent = '';
    tile.className = 'tile';
  });

  // Reset keyboard colors
  keyboardEl.querySelectorAll('.key').forEach(key => {
    key.classList.remove('green','yellow','dark');
  });

  setStatus('');
  refreshBoard();
});



})();
</script>
</body>
</html>


<!--stores wrong color the solution-->