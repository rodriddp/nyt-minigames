<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Wordle - HTML/JS</title>
<style>
  :root{
    --bg: #ffffff;
    --tile-border: #d1d5db;
    --tile-bg: #ffffff;
    --tile-text: #000000;
    --green: #6aaa64;
    --yellow: #c9b458;
    --gray: #787c7e;
    --keyboard-gray: #d3d6da;
    --kbd-dark: #6b7280;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:#111827;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:20px;
  }

  .container{
    width:min(320px, 92vw);
    display:flex;
    flex-direction:column;
    gap:30px;
    align-items:center;
  }

  /* Game board */
  .board{
    display: grid;
    grid-template-rows: repeat(6, 1fr);
    gap:5px;
    width:100%;
  }
  .row{
    display:grid;
    grid-template-columns: repeat(5, 1fr);
    gap:5px;
  }
  .tile {
    aspect-ratio: 1/1;
    border-radius: 0; 
    border: 2px solid var(--tile-border);
    background: var(--tile-bg);
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: 700;
    font-size: clamp(24px, 4.5vw, 28px);
    color: var(--tile-text);
    text-transform: uppercase;
    user-select: none;
    transform-style: preserve-3d;
  }

  .tile.filled {
    border-color: #888A8C; /* black border when letter typed */
  }

  /* Colors after evaluation */
  .tile.green{
    background: var(--green);
    color: #ffffff;
    border-color: var(--green);
  }
  .tile.yellow{
    background: var(--yellow);
    color: #ffffff;
    border-color: var(--yellow);
  }
  .tile.gray{
    background: var(--gray);
    color: #ffffff;
    border-color: var(--gray);
  }

  /* keyboard */
  .keyboard{
    width:100%;
    display:flex;
    flex-direction:column;
    gap:5px;
    user-select:none;
  }
  .krow{
    display:flex;
    gap:5px;
    justify-content:center;
  }
  .key{
    padding: 15px 10px; /* Increased vertical padding for taller keys */
    min-width: 40px;
    min-height: 50px; /* Added minimum height for consistency */
    border-radius: 6px;
    background: var(--keyboard-gray);
    color: #111827;
    font-weight:600;
    text-transform:uppercase;
    display:flex;
    justify-content:center;
    align-items:center;
    cursor:pointer;
    border: none;
    box-shadow: none;
    user-select:none;
    font-size: 17px;
  }
  .key.big{ min-width: 64px; padding-left:14px; padding-right:14px; min-height: 50px; font-size: 12px; }
    /* Specific styling for Enter key */
  .key[data-key="enter"] {
    font-size: 12px; /* Larger font size for Enter */
    }
    /* Specific styling for Back key */
  .key[data-key="back"] {
    font-size: 16px; /* Smaller font size for Back */
    }
  .key.green{ background: var(--green); color: #fff; }
  .key.yellow{ background: var(--yellow); color: #fff; }
  .key.dark{ background: var(--kbd-dark); color: #fff; }

  .status{
    min-height:22px;
    font-size:14px;
    color:#374151;
    text-align:center;
  }

  @media (max-width:420px){
    .key{ padding: 12px 8px; min-width: 34px; min-height: 40px; font-size: 13px; }
    .key.big{ min-width: 60px; min-height: 40px; }
  }

  .tile.flip {
    animation: flip 600ms ease forwards;
  }

  @keyframes flip {
    0%   { transform: rotateX(0deg);}
    50%  { transform: rotateX(90deg);}
    100% { transform: rotateX(0deg);}
  }
</style>
</head>
<body>
  <div class="container">
    <div class="status" id="status"></div>

    <div class="board" id="board" aria-label="Wordle board">
      <!-- Rows and tiles inserted by JS -->
    </div>

    <div class="keyboard" id="keyboard" aria-label="Keyboard">
      <!-- Keyboard rows will be inserted by JS -->
    </div>

    <small style="color:#6b7280; margin-top:8px">Type with your keyboard or click the keys. Press Enter to submit.</small>
  </div>

<script>
(function(){
  // ---- Config ----
  const SOLUTION = "civil"; // <-- change to any 5-letter word (always lowercase)
  const MAX_ROWS = 6;
  const WORD_LENGTH = 5;

  // ---- State ----
  let board = []; // array of rows, each row is array of letters or ''
  for (let r=0; r<MAX_ROWS; r++){
    const row = Array(WORD_LENGTH).fill('');
    board.push(row);
  }
  let currentRow = 0;
  let currentCol = 0;
  let gameOver = false;

  let VALID_WORDS = new Set();

  const boardEl = document.getElementById('board');
  const keyboardEl = document.getElementById('keyboard');
  const statusEl = document.getElementById('status');

  // Load valid words from external source
  async function loadValidWords() {
    try {
      const response = await fetch('https://gist.githubusercontent.com/dracos/dd0668f281e685bad51479e5acaadb93/raw/valid-wordle-words.txt');
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      const text = await response.text();
      const words = text.split('\n')
        .map(w => w.trim().toLowerCase())
        .filter(w => w.length === WORD_LENGTH);
      VALID_WORDS = new Set(words);
      console.log(`Loaded ${VALID_WORDS.size} valid words`);
    } catch (error) {
      console.error('Failed to load valid words:', error);
      setStatus('Failed to load word list. Any 5-letter input will be accepted.');
      // Optionally, fall back to no validation
    }
  }

  // Build board DOM
  function createBoard(){
    boardEl.innerHTML = '';
    for (let r=0; r<MAX_ROWS; r++){
      const rowEl = document.createElement('div');
      rowEl.className = 'row';
      rowEl.dataset.row = r;
      for (let c=0; c<WORD_LENGTH; c++){
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.row = r;
        tile.dataset.col = c;
        tile.textContent = '';
        rowEl.appendChild(tile);
      }
      boardEl.appendChild(rowEl);
    }
  }

  // Keyboard layout
  const rows = [
    ['q','w','e','r','t','y','u','i','o','p'],
    ['a','s','d','f','g','h','j','k','l'],
    ['enter','z','x','c','v','b','n','m','back']
  ];

  function createKeyboard(){
    keyboardEl.innerHTML = '';
    rows.forEach(r=>{
      const rEl = document.createElement('div');
      rEl.className = 'krow';
      r.forEach(k=>{
        const keyEl = document.createElement('button');
        keyEl.className = 'key';
        if (k === 'enter' || k === 'back') keyEl.classList.add('big');
        keyEl.dataset.key = k;
        keyEl.textContent = k === 'back' ? 'âŒ«' : (k === 'enter' ? 'Enter' : k);
        keyEl.addEventListener('click', ()=> onKey(k));
        rEl.appendChild(keyEl);
      });
      keyboardEl.appendChild(rEl);
    });
  }

  // Update tile visuals based on board state
  function refreshBoard() {
    for (let r = 0; r < MAX_ROWS; r++) {
      for (let c = 0; c < WORD_LENGTH; c++) {
        const tile = boardEl.querySelector(
          `.tile[data-row="${r}"][data-col="${c}"]`
        );
        const ch = board[r][c] || "";
        tile.textContent = ch.toUpperCase();

        if (ch) {
          tile.classList.add("filled");
        } else {
          tile.classList.remove("filled");
        }

        // Remove evaluation colors only if not submitted yet
        if (r >= currentRow) {
          tile.classList.remove("green", "yellow", "gray");
        }
      }
    }
  }

  // Handles key presses (from on-screen keyboard or physical keyboard)
  function onKey(key){
    if (gameOver) return;
    if (key === 'enter'){
      submitGuess();
      return;
    }
    if (key === 'back'){
      handleBackspace();
      return;
    }
    if (/^[a-z]$/.test(key)){
      handleLetter(key);
    }
  }

  function handleLetter(letter){
    if (currentCol >= WORD_LENGTH) return;
    board[currentRow][currentCol] = letter;
    currentCol++;
    refreshBoard();
  }

  function handleBackspace(){
    if (currentCol <= 0) return;
    currentCol--;
    board[currentRow][currentCol] = '';
    refreshBoard();
  }

  // Evaluate guess when Enter is pressed
  function submitGuess(){
    if (currentCol !== WORD_LENGTH) {
      setStatus("Not enough letters");
      return;
    }
    const guess = board[currentRow].join('').toLowerCase();
    if (VALID_WORDS.size > 0 && !VALID_WORDS.has(guess)) {
      setStatus("Not a valid word");
      return;
    }
    evaluateGuess(guess);
  }

  // The Wordle coloring algorithm: greens first, then yellows honoring remaining counts
  function evaluateGuess(guess){
    const solution = SOLUTION.toLowerCase();
    const letters = solution.split('');
    const result = Array(WORD_LENGTH).fill(null); // 'green' | 'yellow' | 'gray'

    // Count occurrences of letters in solution
    const count = {};
    for (let ch of letters){
      count[ch] = (count[ch] || 0) + 1;
    }

    // First pass: greens
    for (let i=0; i<WORD_LENGTH; i++){
      if (guess[i] === solution[i]){
        result[i] = 'green';
        count[guess[i]] -= 1;
      }
    }
    // Second pass: yellows and grays
    for (let i=0; i<WORD_LENGTH; i++){
      if (result[i]) continue; // already green
      const ch = guess[i];
      if (count[ch] && count[ch] > 0){
        result[i] = 'yellow';
        count[ch] -= 1;
      } else {
        result[i] = 'gray';
      }
    }

    // Apply colors to tiles with flip animation
    for (let i = 0; i < WORD_LENGTH; i++) {
      const tile = boardEl.querySelector(
        `.tile[data-row="${currentRow}"][data-col="${i}"]`
      );
      tile.classList.remove("green", "yellow", "gray");
  
      setTimeout(() => {
        tile.classList.add("flip");
  
        // At halfway point (when invisible), apply the new color
        setTimeout(() => {
          tile.classList.add(result[i]);
        }, 300); // 50% of 600ms
  
        // Remove flip class at the end so it can be reapplied on next row
        setTimeout(() => {
          tile.classList.remove("flip");
        }, 600);
      }, i * 400); // stagger tiles one after another
    }

    // Update keyboard colors only after the last tile flip is complete
    const lastTileDelay = (WORD_LENGTH - 1) * 400 + 600; // Total time for last tile to finish flipping
    setTimeout(() => {
      for (let i = 0; i < WORD_LENGTH; i++) {
        const ch = guess[i];
        updateKeyColor(ch, result[i]);
      }
    }, lastTileDelay);

    // Move to next row
    if (guess === solution){
      setTimeout(() => {
        setStatus("You win! ðŸŽ‰");
        gameOver = true;
      }, lastTileDelay);
      // Lock winning row colored; no further input
    } else {
      currentRow++;
      currentCol = 0;
      if (currentRow >= MAX_ROWS){
        setTimeout(() => {
          setStatus(`Game over â€” solution was "${solution.toUpperCase()}"`);
          gameOver = true;
        }, lastTileDelay);
      } else {
        setTimeout(() => {
          setStatus('');
        }, lastTileDelay);
      }
    }
  }

  // Updates the visual color of a keyboard key with priority rules
  function updateKeyColor(letter, color){
    letter = letter.toLowerCase();
    const keyEl = keyboardEl.querySelector(`button[data-key="${letter}"]`);
    if (!keyEl) return;
    // priority: green > yellow > dark (gray)
    if (color === 'green'){
      keyEl.classList.remove('yellow','dark');
      keyEl.classList.add('green');
    } else if (color === 'yellow'){
      if (!keyEl.classList.contains('green')) {
        keyEl.classList.remove('dark');
        keyEl.classList.add('yellow');
      }
    } else if (color === 'gray'){
      if (!keyEl.classList.contains('green') && !keyEl.classList.contains('yellow')){
        keyEl.classList.add('dark');
      }
    }
  }

  // Show a status line for a short time
  function setStatus(text){
    statusEl.textContent = text;
    if (!text) return;
    clearTimeout(statusEl._timer);
    statusEl._timer = setTimeout(() => {
      if (statusEl.textContent === text) statusEl.textContent = '';
    }, 1600);
  }

  // --- Physical keyboard support ---
  window.addEventListener('keydown', (e) => {
    if (gameOver) return;
    if (e.key === 'Enter'){
      onKey('enter');
      e.preventDefault();
      return;
    } else if (e.key === 'Backspace'){
      onKey('back');
      e.preventDefault();
      return;
    } else {
      const k = e.key.toLowerCase();
      if (/^[a-z]$/.test(k)){
        onKey(k);
      }
    }
  });

  // Initialize
  loadValidWords();
  createBoard();
  createKeyboard();
  refreshBoard();

  // For demonstration: you can randomize SOLUTION from a small list
  // (uncomment to use)
  // const some = ['civil','willy','bling','skate','prior','milch'];
  // SOLUTION = some[Math.floor(Math.random()*some.length)];

})();
</script>
</body>
</html>