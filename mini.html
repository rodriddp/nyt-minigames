<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini Crossword</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
      padding: 70px;
    }
    .topbar {
        width: 100%;
        background: #ffffff;
        border-bottom: 1px solid #e5e7eb;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1000;
      }
      
      .topbar-icon {
        height: 40px;
        width: 145px;
        cursor: pointer;
      }

    .gear-container {
      position: relative;
      display: flex;
      align-items: center;
      padding: 0px 75px 0px 0px;
    }

    .gear {
      cursor: pointer;
    }

    .gear img {
      width: 20px;
      height: 20px;
    }

    .dropdown {
      display: none;
      position: absolute;
      right: 0;
      top: calc(100% + 4px);
      background: white;
      border-radius: 8px;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      border: 1px solid rgba(0, 0, 0, 0.05);
      min-width: 130px;
      z-index: 10;
      overflow: hidden;

    }

    .dropdown div {
      padding: 12px 16px;
      cursor: pointer;
      font-size: 14px;
      color: #000;
      transition: background-color 0.15s ease-in-out;
    }

    .dropdown div:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(5, 60px);
      grid-template-rows: repeat(6, 60px);
      border: 0px solid black;
    }

    .cell {
      width: 60px;
      height: 60px;
      background: white;
      border: none;
      position: relative;
      font-size: 26px;
      font-weight: 500;
      text-align: center;
      line-height: 60px;
      cursor: pointer;
      user-select: none;
    }

    input.cell {
      text-transform: uppercase;
      font-size: 26px;
      font-weight: 500;
      text-align: center;
      padding: 0;
      margin: 0;
      border: none;
      caret-color: transparent;
    }

    input.cell:focus {
      outline: none;
      border: 1px solid black;
    }

    .black {
      background: black;
      cursor: default;
      border: none;
    }

    .number {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
    }

    .highlight {
      background: #add8e6 !important;
    }

    .selected {
      background: gold !important;
    }

    .checkmark {
      background: lightblue !important;
      color: black;
    }

    .error {
      background-image: linear-gradient(135deg, transparent 49%, red 49%, red 51%, transparent 51%);
      background-repeat: no-repeat;
      background-size: 100% 100%;
    }

    .clue-box {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      width: 350px;
      margin-top: 20px;
      background: #B0D6FB;
      padding: 12px 20px;
      border-radius: 0px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .clue-box button {
      background: none;
      border: none;
      color: black;
      font-size: 20px;
      font-weight: 500;
      cursor: pointer;
      padding: 16px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s ease-in-out;
    }

    .clue-box button:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    #clue {
      font-size: 16px;
      color: black;
      text-align: center;
      flex: 1;
      margin: 0;
    }

  </style>
</head>
<body>
    <div class="topbar">
        <a href="index.html">
          <img src="icons/nyt_logo.png" alt="Back" class="topbar-icon">
        </a>
        <div class="gear-container">
          <div class="gear">
            <img src="icons/gear.png" alt="Settings">
          </div>
          <div class="dropdown" id="dropdown">
            <div onclick="checkPuzzle()">Check Puzzle</div>
            <div onclick="checkWord()">Check Word</div>
            <div onclick="checkLetter()">Check Letter</div>
          </div>
        </div>
    </div>

  <div class="grid" id="grid"></div>

  <div class="clue-box">
    <button onclick="previousWord()">❮</button>
    <div id="clue">Clue will appear here</div>
    <button onclick="nextWord()">❯</button>
  </div>

  <script>
    // === SOLUTION GRID ===
    const solution = [
      ["#", "#", "V", "O", "I"],
      ["#", "C", "A", "T", "S"],
      ["#", "A", "L", "T", "O"],
      ["B", "L", "U", "E", "#"],
      ["T", "I", "E", "R", "#"],
      ["C", "#", "#", "#", "#"]
    ];

    // === WORDS ===
    let words = [
      // Across
      {number:1, dir:"across", cells:[[0,2],[0,3],[0,4]], clue:"1 Across placeholder"},
      {number:2, dir:"across", cells:[[1,1],[1,2],[1,3],[1,4]], clue:"2 Across placeholder"},
      {number:3, dir:"across", cells:[[2,1],[2,2],[2,3],[2,4]], clue:"3 Across placeholder"},
      {number:4, dir:"across", cells:[[3,0],[3,1],[3,2],[3,3]], clue:"4 Across placeholder"},
      {number:5, dir:"across", cells:[[4,0],[4,1],[4,2],[4,3]], clue:"5 Across placeholder"},

      // Down
      {number:6, dir:"down", cells:[[0,2],[1,2],[2,2],[3,2],[4,2]], clue:"6 Down placeholder"},
      {number:7, dir:"down", cells:[[1,1],[2,1],[3,1],[4,1]], clue:"7 Down placeholder"},
      {number:8, dir:"down", cells:[[3,0],[4,0],[5,0]], clue:"8 Down placeholder"},
      {number:9, dir:"down", cells:[[0,3],[1,3],[2,3],[3,3],[4,3]], clue:"9 Down placeholder"},
      {number:10, dir:"down", cells:[[0,4],[1,4],[2,4]], clue:"10 Down placeholder"}
    ];

    // Sort by number, then across before down
    words = words.sort((a, b) => a.number - b.number || (a.dir === "across" ? -1 : 1));

    const gridEl = document.getElementById("grid");
    const clueEl = document.getElementById("clue");
    const dropdown = document.getElementById("dropdown");
    let selectedWordIndex = null;
    let selectedCellIndex = null;
    let currentR = -1;
    let currentC = -1;
    const cells = [];

    function handleAfterInput(r, c) {
      cells[r][c].classList.remove("error");
      if (selectedWordIndex !== null) {
        const word = words[selectedWordIndex];
        const [cr, cc] = word.cells[selectedCellIndex];
        if (cr === r && cc === c) {
          if (selectedCellIndex < word.cells.length - 1) {
            const nextIdx = selectedCellIndex + 1;
            const [nr, nc] = word.cells[nextIdx];
            selectWord(selectedWordIndex, nextIdx);
          } else {
            // Jump to the first letter of the next word after inputting the last letter
            const nextWordIdx = (selectedWordIndex + 1) % words.length;
            selectWord(nextWordIdx, 0);
          }
        }
      }
    }

    function createGrid() {
        for (let r = 0; r < 6; r++) {
          cells[r] = [];
          for (let c = 0; c < 5; c++) {
            let cell;
            if (solution[r][c] === "#") {
              cell = document.createElement("div");
              cell.classList.add("cell", "black");
            } else {
              cell = document.createElement("input");
              cell.type = "text";
              cell.maxLength = 1;
              cell.classList.add("cell");
              cell.addEventListener("click", () => handleCellClick(r, c));
              cell.addEventListener("focus", () => handleCellFocus(r, c));
              cell.addEventListener("input", (e) => handleCellInput(e, r, c));
              cell.addEventListener("keydown", (e) => handleCellKeyDown(e, r, c));
            }
            gridEl.appendChild(cell);
            cells[r][c] = cell;
      
            // Set all borders to 1px #606060 (uniform internal color)
            cell.style.border = '1px solid #606060';
      
            // Override outer edges to 2px black
            if (c === 0) {
              cell.style.borderLeft = '2px solid black';
            }
            if (r === 0) {
              cell.style.borderTop = '2px solid black';
            }
            if (c === 4) {
              cell.style.borderRight = '2px solid black';
            }
            if (r === 5) {
              cell.style.borderBottom = '2px solid black';
            }
          }
        }
        // Add numbers to first cells of words
        words.forEach(w => {
          const [r, c] = w.cells[0];
          const cell = cells[r][c];
          if (solution[r][c] !== "#" && !cell.querySelector(".number")) {
            const num = document.createElement("div");
            num.classList.add("number");
            num.textContent = w.number;
            cell.style.position = "relative";
            cell.appendChild(num);
          }
        });
      }

    function handleCellClick(r, c) {
      const isCurrent = currentR === r && currentC === c && selectedWordIndex !== null;
      if (isCurrent) {
        const acrossIdx = words.findIndex(w => w.dir === "across" && w.cells.some(([wr, wc]) => wr === r && wc === c));
        const downIdx = words.findIndex(w => w.dir === "down" && w.cells.some(([wr, wc]) => wr === r && wc === c));
        if (acrossIdx !== -1 && downIdx !== -1) {
          const targetIdx = selectedWordIndex === acrossIdx ? downIdx : acrossIdx;
          const cellIdx = words[targetIdx].cells.findIndex(([wr, wc]) => wr === r && wc === c);
          selectWord(targetIdx, cellIdx);
          return;
        }
      }
      selectCellDefault(r, c);
    }

    function handleCellFocus(r, c) {
      if (currentR !== r || currentC !== c) {
        selectCellDefault(r, c);
      }
    }

    function handleCellInput(e, r, c) {
      let val = e.data ? e.data.toUpperCase() : e.target.value.toUpperCase();

      if (e.target.disabled) {
        e.target.value = solution[r][c]; // restore correct answer if immutable
        return;
      }

      // Replace old letter with new one
      e.target.value = val.slice(-1);

      if (e.target.value.length === 1) {
        handleAfterInput(r, c);
      } else {
        e.target.classList.remove("error");
      }
    }

    function handleCellKeyDown(e, r, c) {
      const cell = cells[r][c];
      if (cell.disabled) return;

      if (e.key === "Backspace") {
        if (cell.value !== "") {
          // just clear current cell
          cell.value = "";
          e.preventDefault();
        } else if (selectedWordIndex !== null && selectedCellIndex > 0) {
          // move to previous cell if empty
          const prevIdx = selectedCellIndex - 1;
          const [pr, pc] = words[selectedWordIndex].cells[prevIdx];
          selectWord(selectedWordIndex, prevIdx);
          cells[pr][pc].value = "";
          e.preventDefault();
        }
      } else if (/^[a-zA-Z]$/.test(e.key)) {
        // Handle typing a letter: replace the current cell's value
        const newVal = e.key.toUpperCase();
        cell.value = newVal;
        e.preventDefault(); // Prevent default insertion to ensure clean replacement
        handleAfterInput(r, c);
      }
    }

    function selectCellDefault(r, c) {
      const acrossIdx = words.findIndex(w => w.dir === "across" && w.cells.some(([wr, wc]) => wr === r && wc === c));
      const downIdx = words.findIndex(w => w.dir === "down" && w.cells.some(([wr, wc]) => wr === r && wc === c));
      let chosenIdx = -1;
      if (acrossIdx !== -1) {
        chosenIdx = acrossIdx;
      } else if (downIdx !== -1) {
        chosenIdx = downIdx;
      }
      if (chosenIdx === -1) return;
      const cellIdx = words[chosenIdx].cells.findIndex(([wr, wc]) => wr === r && wc === c);
      selectWord(chosenIdx, cellIdx);
      currentR = r;
      currentC = c;
    }

    function selectWord(wordIndex, cellIndex = 0) {
      clearHighlights();
      selectedWordIndex = wordIndex;
      selectedCellIndex = cellIndex;
      const wordCells = words[wordIndex].cells;
      wordCells.forEach(([rr, cc]) => {
        const cell = cells[rr][cc];
        if (solution[rr][cc] !== "#") {
          cell.classList.add("highlight");
        }
      });
      const [sr, sc] = wordCells[cellIndex];
      const selCell = cells[sr][sc];
      selCell.classList.add("selected");
      if (selCell.tagName === "INPUT") {
        if (selCell.disabled) {
          selCell.disabled = false;
          selCell.classList.remove("checkmark");
        }
        selCell.focus();
        // Select all text in the input to ensure typing replaces it
        selCell.select();
      }
      clueEl.textContent = words[wordIndex].clue;
      currentR = sr;
      currentC = sc;
    }

    function clearHighlights() {
      for (let rr = 0; rr < 6; rr++) {
        for (let cc = 0; cc < 5; cc++) {
          if (solution[rr][cc] !== "#") {
            cells[rr][cc].classList.remove("highlight", "selected");
          }
        }
      }
    }

    function nextWord() {
      if (selectedWordIndex === null) {
        selectWord(0, 0);
      } else {
        const nextIdx = (selectedWordIndex + 1) % words.length;
        selectWord(nextIdx, 0);
      }
    }

    function previousWord() {
      if (selectedWordIndex === null) {
        const prevIdx = words.length - 1;
        selectWord(prevIdx, 0);
      } else {
        const prevIdx = (selectedWordIndex - 1 + words.length) % words.length;
        selectWord(prevIdx, 0);
      }
    }

    // === CHECKING FUNCTIONS ===
    function checkPuzzle() {
      for (let r = 0; r < 6; r++) {
        for (let c = 0; c < 5; c++) {
          if (solution[r][c] === "#") continue;
          const cell = cells[r][c];
          cell.classList.remove("checkmark", "error");
          if (cell.tagName === "INPUT" && cell.disabled) cell.disabled = false;
          const val = cell.value;
          if (val === solution[r][c]) {
            cell.classList.add("checkmark");
            if (cell.tagName === "INPUT") cell.disabled = true;
          } else if (val !== "") {
            cell.classList.add("error");
          }
        }
      }
    }

    function checkWord() {
      if (selectedWordIndex === null) return;
      const wcells = words[selectedWordIndex].cells;
      wcells.forEach(([r, c]) => {
        const cell = cells[r][c];
        cell.classList.remove("checkmark", "error");
        if (cell.tagName === "INPUT" && cell.disabled) cell.disabled = false;
        const val = cell.value;
        if (val === solution[r][c]) {
          cell.classList.add("checkmark");
          if (cell.tagName === "INPUT") cell.disabled = true;
        } else if (val !== "") {
          cell.classList.add("error");
        }
      });
    }

    function checkLetter() {
      if (selectedWordIndex === null || selectedCellIndex === null) return;
      const [r, c] = words[selectedWordIndex].cells[selectedCellIndex];
      const cell = cells[r][c];
      cell.classList.remove("checkmark", "error");
      if (cell.tagName === "INPUT" && cell.disabled) cell.disabled = false;
      const val = cell.value;
      if (val === solution[r][c]) {
        cell.classList.add("checkmark");
        if (cell.tagName === "INPUT") cell.disabled = true;
      } else if (val !== "") {
        cell.classList.add("error");
      }
    }

    // === SETTINGS GEAR ===
    document.querySelector(".gear").addEventListener("click", () => {
      dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
    });

    createGrid();
  </script>
</body>
</html>