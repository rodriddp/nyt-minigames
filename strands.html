<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Word Grid â€” styled</title>
<style>
  html,body { height:100%; margin:0; }
  body {
    font-family: sans-serif;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding: 96px;
    box-sizing: border-box;
    background: #fafafa;
  }
  .topbar {
    width: 100%;
    background: #ffffff;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    align-items: center;
    padding: 8px 12px;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1000;
  }
  
  .topbar-icon {
    height: 40px;
    width: 145px;
    cursor: pointer;
  }

  .game {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  .theme {
    display: flex;
    flex-direction: column;
    width: 100%;
    border-radius: 10px;
  }
  
  .theme-top {
    background: lightblue;
    height: 25%; /* 1/4 of the parent height */
    padding: 10px;
    font-size: 14px;
    font-weight: 400; /* Thin text */
    text-align: center;
    color: black;
    border-radius: 10px 10px 0 0;
  }
  
  .theme-bottom {
    background: white;
    height: 75%; /* 3/4 of the parent height */
    padding: 10px;
    font-size: 20px;
    font-weight: bold; /* Bold text */
    text-align: center;
    color: black;
    border: 1px solid #d3d3d3; /* 1px light grey border */
    border-top: none; /* Avoid double border with top */
    border-radius: 0 0 10px 10px; /* Rounded bottom edges */
  }
  .found-count { margin: 4px 0; }
  .current-word { font-size: 24px; text-align: center; min-height:28px; }
  .current-word.error { font-size: 20px; color: rgb(3, 3, 3); } /* Visual cue for error messages */

  .grid {
    position: relative;
    display: inline-block;
    padding: 8px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.06);
  }

  .row { display: flex; }
  .letter {
    width: 40px; height: 40px; margin: 5px;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer; color: black;
    position: relative; user-select: none; z-index: 1;
  }

  .letter.selected::after,
  .letter.found-blue::after,
  .letter.found-yellow::after {
    content: "";
    position: absolute;
    width: 40px; height: 40px;
    border-radius: 50%;
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    z-index: -1;
  }
  .letter.selected::after { background: #DBD8C7; }
  .letter.found-blue::after { background: #B8DEEC; }
  .letter.found-yellow::after { background: #F1D046; }

  .letter.hint-highlight::after {
    content: "";
    position: absolute;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: -1;
    border: 2px dashed lightblue;
    background: transparent;
  }

  .hint-button {
    background: white; color: black; border: 1px solid #333;
    border-radius: 20px; padding: 10px 20px; cursor: pointer; font-size: 16px;
  }
  .inverted { background: black; color: white; }

  .controls {
    display: flex;
    align-items: center;
    gap: 40px;
    justify-content: center;
    margin-top: 25px;
  }

  svg.edges {
    position: absolute;
    top: 0; left: 0;
    pointer-events: none;
    z-index: 0;
    overflow: visible;
  }
</style>
</head>
<body>
  <div class="topbar">
    <a href="index.html">
      <img src="icons/nyt_logo.png" alt="Back" class="topbar-icon">
    </a>
  </div>
  <div class="game">
    <div class="theme">
        <div class="theme-top">TODAY'S THEME</div>
        <div class="theme-bottom">Planning ahead</div>
    </div>
    <div class="current-word"></div>
    <div class="grid">
        <svg class="edges"></svg>
    </div>
    <div class="controls">
      <button class="hint-button">Hint</button>
      <div class="found-count">0 of 6 theme words found.</div>
    </div>
</div>

<script>
const gridLetters = [
  "ITARSA".split(''),
  "URIEMR".split(''),
  "GIDOHA".split(''),
  "SRIYPS".split(''),
  "BIRTAW".split(''),
  "IPSRWA".split(''),
  "DTOKOL".split(''),
  "ENANGE".split('')
];
const themeWords = ['IRIS','RIPTIDE', 'HOME', 'DIRTYPAWS', 'WORKSONG', 'ANGELA'];
const spangram = 'GUITARSARA';
const allSolutions = [...themeWords, spangram];
const wordToPath = {
  'IRIS':[[1,2],[1,1],[2,1],[3,0]],
  'RIPTIDE': [[3,1],[4,1],[4,0],[5,0],[5,1],[6,0],[7,0]],
  'HOME': [[2,4],[2,3],[1,4],[1,3]],
  'DIRTYPAWS': [[2,2],[3,2],[4,2],[4,3],[3,3],[3,4],[4,4],[4,5],[3,5]],
  'WORKSONG': [[5,4],[6,4],[5,3],[6,3],[5,2],[6,2],[7,1],[6,1]],
  'ANGELA': [[7,2],[7,3],[7,4],[7,5],[6,5],[5,5]],
  'GUITARSARA': [[2,0],[1,0],[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[1,5],[2,5]]
};

let found = new Set();
let currentPath = [];
let permanentEdges = [];
let mistakeCount = 0;
let spentHints = 0;
let words = new Set();
let mouseDown = false;
let hasMoved = false;
let startR, startC;
let currentHintWord = null;
let usedWords = new Set();

async function loadDictionary() {
  try {
    const res = await fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt');
    const text = await res.text();
    words = new Set(text.split('\n').map(w => w.trim().toLowerCase()).filter(w => w.length >= 4));
  } catch (e) {
    console.error('Failed to load dictionary. Using fallback.');
    words = new Set(['amen', 'real', 'word', 'test', 'laser', 'angel']);
  }
  allSolutions.forEach(w => words.add(w.toLowerCase()));
}
loadDictionary();

const grid = document.querySelector('.grid');
const edgesSvg = document.querySelector('svg.edges');
const currentWordDiv = document.querySelector('.current-word');
const foundCountDiv = document.querySelector('.found-count');
const hintButton = document.querySelector('.hint-button');
hintButton.addEventListener('click', handleHint);

function updateHintButton() {
  const earned = Math.floor(mistakeCount / 3);
  const hintsAvailable = earned - spentHints;
  const currentProgress = mistakeCount % 3;
  let filledFraction = currentProgress / 3;
  if (hintsAvailable > 0) {
    filledFraction = 1;
    hintButton.classList.add('inverted');
  } else {
    hintButton.classList.remove('inverted');
  }
  hintButton.style.background = `linear-gradient(to right, lightgray ${filledFraction * 100}%, white ${filledFraction * 100}%)`;
}

function clearHints() {
  document.querySelectorAll('.hint-highlight').forEach(el => el.classList.remove('hint-highlight'));
}

function handleHint() {
  const hintsAvailable = Math.floor(mistakeCount / 3) - spentHints;
  if (hintsAvailable <= 0) return;
  spentHints += 1;
  updateHintButton();
  
  if (currentHintWord) return;

  const unsolved = themeWords.filter(w => !found.has(w));
  if (unsolved.length === 0) return;
  
  currentHintWord = unsolved[Math.floor(Math.random() * unsolved.length)];
  const path = wordToPath[currentHintWord];
  path.forEach(([r, c]) => getCell(r, c).classList.add('hint-highlight'));
}

function isAdjacent(p1, p2) {
  const dr = Math.abs(p1[0] - p2[0]);
  const dc = Math.abs(p1[1] - p2[1]);
  return dr <= 1 && dc <= 1 && !(dr === 0 && dc === 0);
}

function showMessage(message, duration = 3000) {
  currentWordDiv.classList.add('error');
  currentWordDiv.textContent = message;
  setTimeout(() => {
    currentWordDiv.classList.remove('error');
    if (currentPath.length > 0) {
      currentWordDiv.textContent = currentPath.map(([rr, cc]) => gridLetters[rr][cc]).join('').toUpperCase();
    } else {
      currentWordDiv.textContent = '';
      clearPath();
    }
  }, duration);
}

function clearPath() {
  document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
  currentPath = [];
  currentWordDiv.textContent = '';
  drawEdges();
}

function submit() {
  if (currentPath.length < 4) {
    clearPath();
    return;
  }
  const word = currentPath.map(([r, c]) => gridLetters[r][c]).join('').toUpperCase();
  const lower = word.toLowerCase();
  console.log(`Submitting word: ${word}, lowercase: ${lower}, usedWords:`, Array.from(usedWords));
  if (usedWords.has(lower)) {
    console.log(`Word ${lower} already in usedWords, showing message`);
    showMessage("Word already found...");
    return;
  }
  if (!words.has(lower)) {
    console.log(`Invalid word: ${lower}, not adding to usedWords`);
    showMessage("Not a word...");
    clearPath();
    return;
  }
  usedWords.add(lower); // Add valid word to usedWords
  if (allSolutions.includes(word)) {
    console.log(`Found solution word: ${word}`);
    const isSpangram = word === spangram;
    const className = isSpangram ? 'found-yellow' : 'found-blue';
    currentPath.forEach(([r, c]) => getCell(r, c).classList.add(className));
    found.add(word);
    foundCountDiv.textContent = `${found.size} of 6 theme words found.`;

    if (word === currentHintWord) {
      clearHints();
      currentHintWord = null;
    }

    for (let i = 1; i < currentPath.length; i++) {
      const [r1, c1] = currentPath[i - 1];
      const [r2, c2] = currentPath[i];
      let color = className === 'found-blue' ? "#B8DEEC" : (className === 'found-yellow' ? "#F1D046" : "#DBD8C7");
      permanentEdges.push([r1, c1, r2, c2, color]);
    }
  } else {
    console.log(`Valid but non-solution word: ${lower}, mistakeCount: ${mistakeCount + 1}`);
    mistakeCount += 1;
    updateHintButton();
    showMessage("Not a theme word...");
  }
  clearPath();
}

function handleMouseDown(r, c) {
  mouseDown = true;
  hasMoved = false;
  startR = r;
  startC = c;
  if (currentHintWord && !found.has(currentHintWord)) {
    return;
  }
  clearHints();
  currentHintWord = null;
}

function handleMouseMove(r, c, event) {
  if (!mouseDown || event.buttons !== 1) return;
  if (!hasMoved) {
    hasMoved = true;
    currentPath = [[startR, startC]];
    getCell(startR, startC).classList.add('selected');
    const word = currentPath.map(([rr, cc]) => gridLetters[rr][cc]).join('').toUpperCase();
    currentWordDiv.textContent = word;
    drawEdges();
  }

  const pos = [r, c];
  const last = currentPath[currentPath.length - 1];

  if (isAdjacent(last, pos)) {
    const indexInPath = currentPath.findIndex(p => p[0] === r && p[1] === c);

    if (indexInPath === -1) {
      currentPath.push(pos);
      getCell(r, c).classList.add('selected');
    } else if (indexInPath < currentPath.length - 1) {
      for (let i = currentPath.length - 1; i > indexInPath; i--) {
        const [rr, cc] = currentPath[i];
        getCell(rr, cc).classList.remove('selected');
      }
      currentPath = currentPath.slice(0, indexInPath + 1);
    }

    const word = currentPath.map(([rr, cc]) => gridLetters[rr][cc]).join('').toUpperCase();
    currentWordDiv.textContent = word;
    drawEdges();
  }
}

function handleMouseUp(r, c) {
  if (mouseDown) {
    mouseDown = false;
    if (hasMoved) {
      submit();
    } else {
      const pos = [r, c];
      if (currentPath.length === 0) {
        currentPath = [pos];
        getCell(r, c).classList.add('selected');
      } else {
        const last = currentPath[currentPath.length - 1];
        if (last[0] === r && last[1] === c) {
          submit();
          return;
        }
        if (isAdjacent(last, pos) && !currentPath.some(p => p[0] === r && p[1] === c)) {
          currentPath.push(pos);
          getCell(r, c).classList.add('selected');
        } else {
          clearPath();
          currentPath = [pos];
          getCell(r, c).classList.add('selected');
        }
      }
      drawEdges();
      const word = currentPath.map(([rr, cc]) => gridLetters[rr][cc]).join('').toUpperCase();
      currentWordDiv.textContent = word;
    }
  }
}

function getCell(r, c) {
  return grid.children[r + 1].children[c];
}

function drawEdges() {
  edgesSvg.innerHTML = "";

  for (const [r1, c1, r2, c2, color] of permanentEdges) {
    drawLine(r1, c1, r2, c2, color);
  }

  for (let i = 1; i < currentPath.length; i++) {
    const [r1, c1] = currentPath[i - 1];
    const [r2, c2] = currentPath[i];
    const cell1 = getCell(r1, c1);
    let color = "#DBD8C7";
    if (cell1.classList.contains('found-yellow')) color = "#F1D046";
    else if (cell1.classList.contains('found-blue')) color = "#B8DEEC";
    drawLine(r1, c1, r2, c2, color);
  }
}

function drawLine(r1, c1, r2, c2, color) {
  const cell1 = getCell(r1, c1);
  const cell2 = getCell(r2, c2);
  const rect1 = cell1.getBoundingClientRect();
  const rect2 = cell2.getBoundingClientRect();
  const gridRect = grid.getBoundingClientRect();
  const x1 = rect1.left - gridRect.left + rect1.width / 2;
  const y1 = rect1.top - gridRect.top + rect1.height / 2;
  const x2 = rect2.left - gridRect.left + rect2.width / 2;
  const y2 = rect2.top - gridRect.top + rect2.height / 2;

  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", x1);
  line.setAttribute("y1", y1);
  line.setAttribute("x2", x2);
  line.setAttribute("y2", y2);
  line.setAttribute("stroke", color);
  line.setAttribute("stroke-width", "12");
  line.setAttribute("stroke-linecap", "round");
  edgesSvg.appendChild(line);
}

/* build grid */
gridLetters.forEach((rowLetters, r) => {
  const row = document.createElement('div');
  row.classList.add('row');
  rowLetters.forEach((letter, c) => {
    const letDiv = document.createElement('div');
    letDiv.classList.add('letter');
    letDiv.textContent = letter;
    letDiv.addEventListener('mousedown', () => handleMouseDown(r, c));
    letDiv.addEventListener('mousemove', (event) => handleMouseMove(r, c, event));
    letDiv.addEventListener('mouseup', () => handleMouseUp(r, c));
    row.appendChild(letDiv);
  });
  grid.appendChild(row);
});

window.addEventListener('resize', () => {
  edgesSvg.setAttribute("width", grid.offsetWidth);
  edgesSvg.setAttribute("height", grid.offsetHeight);
  if (currentPath.length > 1 || permanentEdges.length > 0) drawEdges();
});

window.addEventListener('mouseup', () => {
  if (mouseDown && hasMoved) {
    mouseDown = false;
    hasMoved = false;
    submit();
  } else if (mouseDown) {
    mouseDown = false;
    hasMoved = false;
  }
});

updateHintButton();
</script>
</body>
</html>
<!-- Mostrar SPANGRAM and WORDS when found --> 
<!-- Clear path when word already found-->
<!-- path on top of hint-->
<!-- finish game -->
<!-- back to minigames button -->
<!-- hints black when totally filled -->