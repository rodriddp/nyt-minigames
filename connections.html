<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Connections - HTML/JS (animated, fixed)</title>
<style>
  body {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    background: #f8f9fa;
    margin: 0;
    padding: 75px 20px 20px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .topbar {
    width: 100%;
    background: #ffffff; 
    border-bottom: 1px solid #e5e7eb; 
    display: flex;
    align-items: center;
    padding: 8px 12px;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1000;
  }
  .topbar-icon { height: 40px; width: 145px; cursor: pointer; }

  .page-wrapper {
    transform: scale(0.8);
    transform-origin: top center;
    text-align: center;
  }
  h1 { font-weight: 400; font-size: 15px; margin-bottom: 20px; color: #515043; }

  .grid {
    display: grid;
    grid-template-columns: repeat(4, 100px);
    grid-auto-rows: 100px;
    gap: 10px;
    width: max-content;
    position: relative;
  }
  .tile {
    background: #EFEFE6;
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    /*font-size: 14px;*/
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s, transform 0.2s;
    user-select: none;
  }
  .tile.selected { background: #59594E; color: #F8F8F8; transform: scale(1.05); }
  .tile.correct { cursor: default; color: white; }

  .group-yellow { background: #fbe48c; }
  .group-green  { background: #9dd296; }
  .group-blue   { background: #91b9e3; }
  .group-purple { background: #c5a3d8; }

  @keyframes shake { 0%{transform:translateX(0)}10%{transform:translateX(-5px)}20%{transform:translateX(5px)}30%{transform:translateX(-5px)}40%{transform:translateX(5px)}50%{transform:translateX(-5px)}60%{transform:translateX(5px)}70%{transform:translateX(-5px)}80%{transform:translateX(5px)}90%{transform:translateX(-5px)}100%{transform:translateX(0)} }
  .tile.shake { animation: shake 1s; }

  .lives-container { display:flex; align-items:center; margin:20px 0; gap:10px; justify-content:center; width:100%; }
  .lives-label { font-weight:400; font-size:15px; color:#515043; }
  .lives { display:flex; gap:8px; }
  .life { width:12px; height:12px; border-radius:50%; border:2px solid #59594E; background:#59594E; }
  .life.shrink { animation: shrinkOut 0.4s forwards; }
  @keyframes shrinkOut { 0%{transform:scale(1);opacity:1}100%{transform:scale(0);opacity:0} }

  .actions { display:flex; gap:15px; margin-top:10px; justify-content:center; width:100%; }
  .btn {
    padding: 10px 20px; 
    border: 1px solid #333; 
    border-radius: 25px; 
    background: white; 
    cursor: pointer; 
    font-weight: bold; 
    color: black;
    transition: filter 0.2s; /* Smooth transition for filter */
    -webkit-appearance: none; 
    appearance: none; 
    -webkit-tap-highlight-color: transparent;
  }
  
  .btn:hover:active {
    filter: invert(100%); /* Only invert when hovering AND clicking */
  }
  
  .btn:not(:hover):not(:active) {
    filter: none; /* Explicitly reset when not hovering or clicking */
  }
  
  /* Optional: Handle focus state to avoid inversion on click focus */
  .btn:focus {
    filter: none; /* Ensure focus doesn't trigger inversion */
    outline: none; /* Remove default focus outline (optional, can style differently) */
  }
  .long-tile {
    display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center;
    border-radius:8px; color:black; font-size:14px; font-weight:bold; grid-column:span 4; padding:5px;
    transform: translateY(-10px); opacity:0; transition: transform 0.5s ease-out, opacity 0.5s ease-out;
  }
  .long-tile.show { transform: translateY(0); opacity:1; }
  .long-tile .subtitle { font-weight:400; font-size:14px; text-align:center; }

  /* overlay clones used for animation */
  .anim-overlay {
    position: fixed;
    left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2000;
  }
  .anim-clone {
    position: absolute;
    border-radius: 8px;
    display:flex; justify-content:center; align-items:center; text-align:center; font-weight:bold;
    transition: transform 0.5s cubic-bezier(.2,.8,.2,1), width 0.25s ease, height 0.25s ease, left 0.5s cubic-bezier(.2,.8,.2,1), top 0.5s cubic-bezier(.2,.8,.2,1), opacity 0.3s ease;
    box-sizing: border-box;
    padding: 6px;
  }
  .merge-clone {
    transition: transform 0.25s ease, opacity 0.25s ease, left 0.25s ease, top 0.25s ease, width 0.25s ease, height 0.25s ease;
  }

  /* helper: text inside merge clone */
  .merge-title { font-weight:700; font-size:14px; line-height:1.1; text-align:center; padding:2px 8px; }
  .merge-sub { font-weight:400; font-size:14px; text-align:center; opacity:1; padding-top:0px; }

</style>
</head>
<body>
  <div class="topbar">
    <a href="index.html">
      <img src="icons/nyt_logo.png" alt="Back" class="topbar-icon">
    </a>
  </div>
  <div class="page-wrapper">
    <h1>Create four groups of four!</h1>
    <div class="grid" id="grid"></div>

    <div class="lives-container">
      <div class="lives-label">Mistakes remaining:</div>
      <div class="lives" id="lives"></div>
    </div>

    <div class="actions">
      <button class="btn" onclick="shuffleTiles()">Shuffle</button>
      <button class="btn" onclick="deselectAll()">Deselect All</button>
      <button class="btn" id="submitBtn" onclick="submitSelection()">Submit</button>
    </div>

    <div id="message" style="margin-top:15px; font-weight:bold;"></div>
  </div>

  <!-- overlay used for animation clones -->
  <div id="animOverlay" class="anim-overlay" aria-hidden="true"></div>

  <script>
    const categories = [
      { name: "THEY FORM A NICKNAME WHEN COMBINED WITH SARA", color: "group-yellow", words: ["BACÍN", "JEVO", "WARMA", "VILLOSO"] },
      { name: "DATES THAT WE WHERE ON (WHEN WE WERE NOT DATING)", color: "group-green", words: ["SUSHI", "TAYLOR", "ROOFTOP", "ICE SKATING"] },
      { name: "NORWAY ROADTRIP STARTER PACK", color: "group-blue", words: ["XC60", "WIPES", "MARSHMALLOWS", "MINK"] },
      { name: "RHYMES WITH GOTHENBURG FRIENDS", color: "group-purple", words: ["CHÂTEAU", "KOREAN", "DILEMMA", "CHIA"] }
    ];

    let words = categories.flatMap(c => c.words).sort(() => Math.random() - 0.5);
    const grid = document.getElementById("grid");
    const message = document.getElementById("message");
    const livesContainer = document.getElementById("lives");
    const animOverlay = document.getElementById("animOverlay");
    let selected = [];
    let mistakes = 4;
    let solvedGroups = 0;
    let fusedTiles = [];

    const pageWrapper = document.querySelector('.page-wrapper');
    const transformStyle = window.getComputedStyle(pageWrapper).transform;
    const matrix = new DOMMatrix(transformStyle);
    const scale = matrix.a;

    function renderLives() {
      livesContainer.innerHTML = "";
      for (let i = 0; i < mistakes; i++) {
        const circle = document.createElement("div");
        circle.className = "life";
        livesContainer.appendChild(circle);
      }
    }
    renderLives();

    function loseLife() {
      const circles = livesContainer.querySelectorAll(".life");
      if (circles.length > 0) {
        const lastLife = circles[circles.length - 1];
        lastLife.classList.add("shrink");
        lastLife.addEventListener("animationend", () => {
          lastLife.remove();
        }, { once: true });
      }
    }

    function renderGrid() {
      grid.innerHTML = "";
      // fused tiles are rendered first (top)
      fusedTiles.forEach(tile => grid.appendChild(tile));
      words.forEach(word => {
        const div = document.createElement("div");
        div.classList.add("tile");
        div.textContent = word;
        div.onclick = () => toggleSelect(div);
        grid.appendChild(div);
        adjustFont(div);
      });
    }

    function toggleSelect(tile) {
      if (tile.classList.contains("correct")) return;
      if (selected.includes(tile)) {
        tile.classList.remove("selected");
        selected = selected.filter(t => t !== tile);
      } else if (selected.length < 4) {
        tile.classList.add("selected");
        selected.push(tile);
      }
    }

    function deselectAll() {
      selected.forEach(t => t.classList.remove("selected"));
      selected = [];
    }

    function shuffleTiles() {
      words = words.sort(() => Math.random() - 0.5);
      renderGrid();
      deselectAll();
    }

    function adjustFont(tile) {
      let fontSize = 14;
      const minFont = 8;
      tile.style.fontSize = fontSize + "px";
      while ((tile.scrollWidth > tile.clientWidth || tile.scrollHeight > tile.clientHeight) && fontSize > minFont) {
        fontSize -= 1;
        tile.style.fontSize = fontSize + "px";
      }
    }

    // Helper: create an absolute-positioned clone at the same rect
    function createCloneFromElement(el) {
      const rect = el.getBoundingClientRect();
      const clone = document.createElement("div");
      clone.className = "anim-clone";
      clone.style.left = rect.left + "px";
      clone.style.top = rect.top + "px";
      clone.style.width = rect.width + "px";
      clone.style.height = rect.height + "px";
      clone.style.fontSize = (parseFloat(window.getComputedStyle(el).fontSize) * scale) + "px";
      clone.style.background = window.getComputedStyle(el).backgroundColor;
      clone.style.color = window.getComputedStyle(el).color;
      clone.textContent = el.textContent;
      clone.dataset.original = el.textContent;

      // Apply scale adjustments for visual consistency
      clone.style.borderRadius = (8 * scale) + "px";
      clone.style.padding = (6 * scale) + "px";

      animOverlay.appendChild(clone);
      return { clone, rect };
    }

    // Find topmost available row tiles (within remaining unfused grid)
    function findTopRowTiles() {
      // All `.tile` elements (fused long tiles are not '.tile' but '.long-tile')
      const tileEls = Array.from(grid.querySelectorAll('.tile'));
      // top row are first 4 tiles in DOM order that belong to grid (accounting for grid columns)
      // If fewer than 4 tiles remain, return however many there are.
      return tileEls.slice(0, 4);
    }

    // main submit flow with animation for correct group
    async function submitSelection() {
      if (selected.length !== 4) return;

      const wordsChosen = selected.map(t => t.textContent);
      const foundCategory = categories.find(cat =>
        cat.words.every(w => wordsChosen.includes(w))
      );

      if (!foundCategory) {
        // incorrect
        mistakes--;
        loseLife();
        selected.forEach(tile => {
          tile.classList.add("shake");
          tile.addEventListener("animationend", () => tile.classList.remove("shake"), { once: true });
        });
        if (mistakes === 0) {
          document.getElementById("submitBtn").disabled = true;
        }
        deselectAll();
        return;
      }

      // CORRECT: animate sequence
      // 1) Identify the topmost available row tiles (the first 4 .tile elements)
      const topRowTiles = findTopRowTiles();

      // Save DOM nodes & rects
      const selectedTiles = [...selected]; // array of tile DOM elements (4)
      const allTileEls = Array.from(grid.querySelectorAll('.tile'));
      const selectedRects = selectedTiles.map(t => t.getBoundingClientRect());
      const topRects = topRowTiles.map(t => t.getBoundingClientRect());

      // Determine top-row tiles that are NOT selected (we will only create clones for those)
      const topNonSelected = topRowTiles.filter(t => !selectedTiles.includes(t));
      const topNonSelectedRects = topNonSelected.map(t => t.getBoundingClientRect());

      // Create clones for selected tiles (always create)
      const clones = [];
      selectedTiles.forEach(t => {
        t.style.visibility = 'hidden';
        clones.push(createCloneFromElement(t));
      });

      // Create clones for top-row tiles that are not selected (avoid duplicating clones for tiles that are in both sets)
      const topClones = [];
      topNonSelected.forEach(t => {
        t.style.visibility = 'hidden';
        topClones.push(createCloneFromElement(t));
      });

      // Phase durations (ms)
      const moveDuration = 500;   // move tiles to swapped positions
      const growDuration = 300;  // grow to overshoot
      const settleDuration = 150; // settle back to 1

      // Force layout
      void animOverlay.offsetHeight;

      // Map selected clones -> topRects (target positions). Keep order as selected array -> top row order.
      clones.forEach((item, idx) => {
        const targetRect = topRects[idx] || selectedRects[idx] || item.rect;
        animateCloneToRect(item.clone, targetRect, moveDuration);
      });

      // Map top non-selected clones -> the selectedRects of tiles that were NOT in top row.
      // Build selected-only rects in the order of selectedTiles where they are not in topRow.
      const selectedOnlyRects = [];
      const selectedOnlyTiles = [];
      selectedTiles.forEach((t, idx) => {
        if (!topRowTiles.includes(t)) {
          selectedOnlyRects.push(selectedRects[idx]);
          selectedOnlyTiles.push(t);
        }
      });
      topClones.forEach((item, idx) => {
        const targetRect = selectedOnlyRects[idx] || selectedRects[idx] || item.rect;
        animateCloneToRect(item.clone, targetRect, moveDuration);
      });

      // Wait for move to finish
      await wait(moveDuration + 10);

      // Remove the moving clones (they're visually in place)
      clones.forEach(c => { if (c.clone.parentNode) c.clone.remove(); });
      topClones.forEach(c => { if (c.clone.parentNode) c.clone.remove(); });

      // Reconstruct words to match the animated positions
      let newWords = new Array(words.length);
      for (let i = 0; i < 4; i++) {
        newWords[i] = selectedTiles[i].textContent;
      }
      const selectedOnlyIndices = selectedOnlyTiles.map(t => allTileEls.indexOf(t));
      for (let j = 0; j < topNonSelected.length; j++) {
        newWords[selectedOnlyIndices[j]] = topNonSelected[j].textContent;
      }
      for (let k = 0; k < words.length; k++) {
        if (newWords[k] === undefined) {
          newWords[k] = words[k];
        }
      }
      words = newWords;
      renderGrid();

      // Compute bounding rect for the top row (destination of selected clones)
      const currentTopRowTiles = Array.from(grid.querySelectorAll('.tile')).slice(0, 4);
      const currentTopRects = currentTopRowTiles.map(t => t.getBoundingClientRect());
      const mergedLeft = Math.min(...currentTopRects.map(r => r.left));
      const mergedTop = Math.min(...currentTopRects.map(r => r.top));
      const mergedRight = Math.max(...currentTopRects.map(r => r.left + r.width));
      const mergedBottom = Math.max(...currentTopRects.map(r => r.top + r.height));
      const mergedRect = { left: mergedLeft, top: mergedTop, width: mergedRight - mergedLeft, height: mergedBottom - mergedTop };

      // --- Create the mergeClone as the FINAL long tile visual (no empty placeholder) ---
      const mergeClone = document.createElement('div');
      mergeClone.className = 'anim-clone merge-clone';
      mergeClone.style.left = mergedRect.left + 'px';
      mergeClone.style.top = mergedRect.top + 'px';
      mergeClone.style.width = mergedRect.width + 'px';
      mergeClone.style.height = mergedRect.height + 'px';
      mergeClone.style.display = 'flex';
      mergeClone.style.flexDirection = 'column';
      mergeClone.style.justifyContent = 'center';
      mergeClone.style.alignItems = 'center';
      mergeClone.style.boxSizing = 'border-box';

      // Apply scale adjustments
      mergeClone.style.borderRadius = (8 * scale) + 'px';
      mergeClone.style.padding = (5 * scale) + 'px';

      // Build internal content (title + subtitle) so the letters are visible immediately
      const mergeTitle = document.createElement('div');
      mergeTitle.className = 'merge-title';
      mergeTitle.style.fontSize = (14 * scale) + 'px';
      mergeTitle.style.padding = '0';
      mergeTitle.style.lineHeight = '1.1';
      mergeTitle.textContent = foundCategory.name;

      const mergeSub = document.createElement('div');
      mergeSub.className = 'merge-sub';
      mergeSub.style.fontSize = (14 * scale) + 'px';
      mergeSub.style.paddingTop = '0';
      mergeSub.style.opacity = '1';
      mergeSub.textContent = foundCategory.words.join(", ");

      mergeClone.appendChild(mergeTitle);
      mergeClone.appendChild(mergeSub);

      // Set background color to category color
      const temp = document.createElement('div');
      temp.className = foundCategory.color;
      document.body.appendChild(temp);
      mergeClone.style.background = window.getComputedStyle(temp).backgroundColor;
      temp.remove();

      // Start smaller for pop effect
      mergeClone.style.opacity = '1';
      mergeClone.style.transform = 'scale(0.9)';

      animOverlay.appendChild(mergeClone);

      // small pause to ensure CSS start state applied
      await wait(10);

      // Grow to overshoot with smooth easing
      mergeClone.style.transition = `transform ${growDuration}ms cubic-bezier(.2, .8, .2, 1)`;
      mergeClone.style.transform = 'scale(1.1)';
      await wait(growDuration);

      // Immediately settle back to 1 with ease
      mergeClone.style.transition = `transform ${settleDuration}ms ease-in-out`;
      mergeClone.style.transform = 'scale(1)';
      await wait(settleDuration + 10);

      // Remove overlay merge clone 
      mergeClone.remove();

      // Now replace the top 4 tiles with the long tile
      const firstRemainingTile = Array.from(grid.querySelectorAll('.tile'))[4] || null;

      // Create real long-tile element and push into fusedTiles
      const longTile = document.createElement("div");
      longTile.className = "long-tile " + foundCategory.color;
      longTile.innerHTML = `<div class="title">${foundCategory.name}</div>
                            <div class="subtitle">${foundCategory.words.join(", ")}</div>`;

      // Set final styles before inserting to avoid transition
      longTile.style.opacity = '1';
      longTile.style.transform = 'translateY(0)';

      fusedTiles.push(longTile);

      // Remove the top row tiles first
      currentTopRowTiles.forEach(t => t.remove());

      // Insert the long tile where the top row was
      grid.insertBefore(longTile, firstRemainingTile);

      // Adjust font for the new long tile
      adjustFont(longTile);

      // Update words by removing the group words
      words = words.filter(w => !wordsChosen.includes(w));

      // finalize state
      solvedGroups++;
      if (solvedGroups === 4) {
        document.getElementById("submitBtn").disabled = true;
      }
      deselectAll();
    }

    // helper to animate a clone element to a rectangle
    function animateCloneToRect(clone, targetRect, duration) {
      clone.style.transition = `left ${duration}ms cubic-bezier(.2,.8,.2,1), top ${duration}ms cubic-bezier(.2,.8,.2,1), width ${duration}ms cubic-bezier(.2,.8,.2,1), height ${duration}ms cubic-bezier(.2,.8,.2,1), transform ${duration}ms cubic-bezier(.2,.8,.2,1)`;
      requestAnimationFrame(() => {
        clone.style.left = targetRect.left + 'px';
        clone.style.top = targetRect.top + 'px';
        clone.style.width = targetRect.width + 'px';
        clone.style.height = targetRect.height + 'px';
      });
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // initial grid render
    renderGrid();

  </script>
</body>
</html>

<!-- include feature of one away --> 
<!-- mistakes + lifes should not shift-->
